status: "accepted"

decision-makers: Denis Smirnov

--------------------------------

# IPC

## Описание проблемы

PostgreSQL использует процессную модель (т.е. каждый бекенд,
обслуживающий соединение клиента, форкается в отдельном процессе
от postmaster). При этом мы хотим вынести исполнитель DataFusion
в отдельный фоновый процесс, т.к. tokio рантайм будет сложно
встраивать в бекенды клиента. Поэтому, нам нужна система
коммуникации между процессами бекендов и фоновым процессом с
DataFusion.

## Факторы принятия решения

1. Решение должно быть производительным. Это подразумевает
   kernel bypass: т.е. стараться оставаться в пространстве
   пользователя и не использовать вызовы ядра.
1. Писать IPC мы хотим на rust из-за лучшего сопровождения
   решения на одном языке.
1. Rust отлавливает проблемы конкуренции только в рамках
   одного адресного пространства (т.е. процесса).
1. Решение должно быть кросс-платформенным, чтобы не отсечь
   потенциальных контрибьюторов из-за того, что под их ноутбук
   что-то не собирается.
1. У PostgreSQL есть своя инфраструктура для IPC через
   общую память.

## Рассматриваемые варианты

При описанных выше вводных вариант остается только один:
использовать общую память PostgreSQL для IPC между бекендами
и фоновым процессом. Тем более что pgrx предоставляет обертки
под rust над инфраструктурой общей памяти.

Использовать сокеты или очереди не хочется, так как это куча
вызовов ядра при каждом запросе. Ну и те же очереди, например,
отсутствуют на macOS, что не удовлетворяет кросс-платформенности.

## Реализация

В PostgreSQL существует два вида работы с общей памятью:
- `shmem.c` - общая память, которая выделяется в postmaster до форка.
  Как следствие, posix гарантирует нам сохранение трансляции памяти
  в дочерних процессах и мы можем использовать абсолютные адреса.
- `dsm.c` - динамическая общая память, которую можно добавить в
  процессы уже после форка. Как следствие, в каждом процессе будут
  свои собственные абсолютные адреса (и можно полагаться только на
  относительные). Частный пример - параллельное сканирование.

Нам нужно использовать `shmem.c` (т.е. обычную общую память до форка).
Высокоуровнево, план работы будет выглядить так:
1. Бекенд, у которого выставлен GUC использования DataFusion,
   в общей памяти из free list получает номер слота, через который
   будет вестись IPC с фоновым процессом. У каждого бекенда и так
   есть свой ID для сигналов, но мы не можем его использовать. Нам
   нужны только бекенды, а в нумерации ID учитываются еще и
   вспомогательные процессы с другими фоновыми процессами. Резервировать
   же никогда неиспользуемые слоты мы не хотим.
   Во free list должны использоваться атомики при операциях со списком
   (spin lock + compare and swap).
1. Через слот производится обмен сообщениями с DataFusion в фоновом
   процессе. Чтобы разбудить ждущий процесс используются сигналы через
   latch (присутствуют по-умолчанию и в бекендах, и в фоновых процессах).
   Дополнительно каждый слот должен быть защищен атомиком на случай ложного
   пробуждения ОС (в этот момент может идти запись или чтение).
1. При завершении бекенда (или при выключении GUC) номер слота возвращается
   во free list.

## Плюсы и минусы

Плюсы:
- кросс-платформенно;
- сообщения не ходят через ядро ОС;
- проверенная в бою инфраструктура общей памяти pg.

Минусы:
- придется использовать небезопасное подмножество rust для работы со
  структурами в общей памяти.
